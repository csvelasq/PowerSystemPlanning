using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Gurobi;
using System.Diagnostics;

namespace PowerSystemPlanning.Solvers.OPF
{
    /// <summary>
    /// Linear programming optimal power flow model (DC power flow, linear generation cost functions).
    /// </summary>
    public class OPFModel : IPowerSystemSolver
    {
        public const string OPFModelName = "Linear Optimal (DC) Power Flow";

        #region Gurobi model
        PowerSystem powerSystem;
        GRBModel model;
        GRBEnv env;
        /// <summary>
        /// Power generated by each generator (in MW).
        /// </summary>
        GRBVar[] PGen;
        /// <summary>
        /// Power flow through each transmission line in the power system (in MW).
        /// </summary>
        GRBVar[] PFlow;
        /// <summary>
        /// Angle (in radians) of each bus (including reference).
        /// </summary>
        GRBVar[] BusAngle;
        /// <summary>
        /// Nodal power balance (for each node).
        /// </summary>
        GRBConstr[] NodalPowerBalance;
        /// <summary>
        /// DC power flow equations (for each transmission line).
        /// </summary>
        GRBConstr[] DCPowerFlow;
        #endregion

        #region Public properties
        /// <summary>
        /// Gets the total generation cost (the model objective value) in the current 
        /// solution of the optimal power flow.
        /// </summary>
        public double TotalGenerationCost
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.ObjVal);
            }
        }

        /// <summary>
        /// Gets the power generated by each generator in the current solution of the optimal power flow.
        /// </summary>
        public double[] PGen_Solution
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.X, this.PGen);
            }
        }
        /// <summary>
        /// Gets the power flow through each transmission line in the current solution of the optimal power flow.
        /// </summary>
        public double[] PFlow_Solution
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.X, this.PFlow);
            }
        }
        #endregion 

        private PowerSystemSolverResults OPFSolverResults;

        /// <summary>
        /// Creates the Gurobi OPF model for the provided power system.
        /// </summary>
        /// <param name="powerSystem">The power system for which the OPF will be solved.</param>
        public OPFModel(PowerSystem powerSystem)
        {
            this.powerSystem = powerSystem;
            this.env = new GRBEnv();
            this.model = new GRBModel(env);
            // Add variables to Gurobi model: power generated by each generator
            PGen = new GRBVar[powerSystem.NumberOfGeneratingUnits];
            for (int i = 0; i < powerSystem.NumberOfGeneratingUnits; i++)
            {
                GeneratingUnit gen = powerSystem.generatingUnits[i];
                PGen[i] = model.AddVar(0, gen.InstalledCapacityMW, gen.MarginalCost, GRB.CONTINUOUS, "PGen" + gen.Id);
            }
            // Add variables to Gurobi model: bus angles
            BusAngle = new GRBVar[powerSystem.NumberOfNodes];
            for (int i = 0; i < powerSystem.NumberOfNodes; i++)
            {
                BusAngle[i] = model.AddVar(-GRB.INFINITY, GRB.INFINITY, 0, GRB.CONTINUOUS, "theta" + powerSystem.nodes[i].Id);
            }
            // Add variables to Gurobi model: power flow through each transmission line
            PFlow = new GRBVar[powerSystem.NumberOfTransmissionLines];
            for (int i = 0; i < powerSystem.NumberOfTransmissionLines; i++)
            {
                TransmissionLine tl = powerSystem.transmissionLines[i];
                PFlow[i] = model.AddVar(-tl.ThermalCapacityMW, tl.ThermalCapacityMW, 0, GRB.CONTINUOUS, "PFlow" + tl.Id);
            }
            // Includes variables in model
            this.model.Update();
            // Sets objective: minimize total generation costs
            this.model.Set(GRB.IntAttr.ModelSense, GRB.MINIMIZE);
            // Creates power balance constraint in each node
            this.NodalPowerBalance = new GRBConstr[powerSystem.NumberOfNodes];
            for (int i = 0; i < powerSystem.NumberOfNodes; i++)
            {
                Node node = powerSystem.nodes[i];
                GRBLinExpr powerBalanceLHS = new GRBLinExpr();
                foreach (GeneratingUnit gen in node.generatingUnits)
                {
                    powerBalanceLHS.AddTerm(1, this.PGen[gen.Id]);
                }
                foreach (TransmissionLine tl in node.incomingTransmissionLines)
                {
                    powerBalanceLHS.AddTerm(+1, PFlow[tl.Id]); //incoming power flow
                }
                foreach (TransmissionLine tl in node.outgoingTransmissionLines)
                {
                    powerBalanceLHS.AddTerm(-1, PFlow[tl.Id]); //outgoing power flow
                }
                // TODO include simple load-shedding
                GRBLinExpr powerBalanceRHS = new GRBLinExpr();
                powerBalanceRHS.AddConstant(node.TotalLoad);
                this.NodalPowerBalance[i] = this.model.AddConstr(powerBalanceLHS, GRB.EQUAL, powerBalanceRHS, "PowerBalanceNode" + i);
            }
            // Creates constraint for defining power flow in each transmission line
            this.DCPowerFlow = new GRBConstr[powerSystem.NumberOfTransmissionLines];
            for (int t = 0; t < powerSystem.NumberOfTransmissionLines; t++)
            {
                TransmissionLine tl = powerSystem.transmissionLines[t];
                GRBLinExpr powerFlowLHS = new GRBLinExpr();
                powerFlowLHS.AddTerm(1, this.PFlow[t]);
                GRBLinExpr powerFlowRHS = new GRBLinExpr();
                powerFlowRHS.AddTerm(+tl.SusceptanceMho, this.BusAngle[tl.NodeFromID]);
                powerFlowRHS.AddTerm(-tl.SusceptanceMho, this.BusAngle[tl.NodeToID]);
                this.DCPowerFlow[t] = this.model.AddConstr(powerFlowLHS, GRB.EQUAL, powerFlowRHS, "PowerFlowTL" + t);
            }
            //FOR DEBUGGING: Writes the resulting model to an output file
            this.model.Write("model.lp");
        }

        /// <summary>
        /// Synchronously solves the Gurobi linear optimal (DC) power flow model.
        /// </summary>
        public void Solve()
        {
            // Initializes result reporting
            this.OPFSolverResults = new PowerSystemSolverResults();
            this.OPFSolverResults.SolverName = OPFModel.OPFModelName;
            this.OPFSolverResults.StartTime = DateTime.Now;
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();
            // Solves the model
            this.model.Optimize();
            // Finalizes result reporting
            int status = this.model.Get(GRB.IntAttr.Status);
            if (status == GRB.Status.OPTIMAL)
            {
                this.OPFSolverResults.Result = new OPFModelResult(this.TotalGenerationCost, this.PGen_Solution, this.PFlow_Solution, status);
            }
            else
            {
                this.OPFSolverResults.Result = new OPFModelResult(status);
            }
            stopwatch.Stop();
            this.OPFSolverResults.ExecutionTime = stopwatch.Elapsed;
            this.OPFSolverResults.StopTime = DateTime.Now;
        }

        public void SolveAsync()
        {
            throw new NotImplementedException();
        }

        public PowerSystemSolverResults getResults()
        {
            return this.OPFSolverResults;
        }

        /// <summary>
        /// Dispose of Gurobi model and env
        /// </summary>
        public void Dispose()
        {
            model.Dispose();
            env.Dispose();
        }
    }

    /// <summary>
    /// Encapsulates results of the OPF model.
    /// </summary>
    public class OPFModelResult
    {
        double _TotalGenerationCost;
        double[] _PowerGenerated;
        double[] _PowerFlows;
        int _GRBStatus;

        /// <summary>
        /// Gets the total generation cost (the model objective value) in the current solution.
        /// </summary>
        public double TotalGenerationCost
        {
            get
            {
                return _TotalGenerationCost;
            }
        }

        /// <summary>
        /// Power generated by each generator (in MW).
        /// </summary>
        public double[] PowerGenerated
        {
            get
            {
                return _PowerGenerated;
            }
        }

        /// <summary>
        /// Power flow through each transmission line in the power system (in MW).
        /// </summary>
        public double[] PowerFlows
        {
            get
            {
                return _PowerFlows;
            }

            set
            {
                _PowerFlows = value;
            }
        }

        /// <summary>
        /// Status of the Gurobi optimization (defined in GRB.Status)
        /// </summary>
        public int GRBStatus
        {
            get
            {
                return _GRBStatus;
            }

            set
            {
                _GRBStatus = value;
            }
        }

        /// <summary>
        /// True if the model was solved to optimality, false otherwise.
        /// </summary>
        public bool IsModelSolved { get { return _GRBStatus == GRB.Status.OPTIMAL; } }

        /// <summary>
        /// True if the model was proved to be infeasible, false otherwise.
        /// </summary>
        public bool IsModelInfeasible { get { return _GRBStatus == GRB.Status.INFEASIBLE; } }

        /// <summary>
        /// True if the model was proved to be unbounded, false otherwise.
        /// </summary>
        public bool IsModelUnbounded { get { return _GRBStatus == GRB.Status.UNBOUNDED; } }

        /// <summary>
        /// Initializes the result container with the given Gurobi status.
        /// </summary>
        /// <param name="status">The Gurobi status of the optimization</param>
        /// <remarks>This constructor can be used to find out if the model was correctly solved by means of the <see cref="IsModelSolved"/> property.</remarks>
        public OPFModelResult(int status)
        {
            this._GRBStatus = status;
        }

        public OPFModelResult(double obj, double[] pgen, double[] pflows, int status)
            : this(status)
        {
            this._TotalGenerationCost = obj;
            this._PowerGenerated = pgen;
            this._PowerFlows = pflows;
        }
    }
}
