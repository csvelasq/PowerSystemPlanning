using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Gurobi;
using System.Diagnostics;
using PowerSystemPlanning.PlanningModels;

namespace PowerSystemPlanning.Solvers.OPF
{
    /// <summary>
    /// Linear programming optimal power flow model (DC power flow, linear generation cost functions).
    /// </summary>
    /// <remarks>
    /// The most simple OPF model based on DC power flow. Load shedding is allowed (modeled as fictitious generation) so the problem is always feasible (by shedding all load in every bus of the power system).
    /// </remarks>
    public class OPFModel : IPowerSystemSolver
    {
        public const string OPFModelName = "Linear Optimal (DC) Power Flow";

        public const double LoadSheddingCost = 9999999999999; //TODO allow configuration of load shedding cost

        PowerSystemDecorator powerSystem;

        List<GeneratingUnitOPFResult> _GeneratingUnitOPFResults;

        List<NodeOPFResult> _NodeOPFResults;

        List<TransmissionLineOPFResult> _TransmissionLineOPFResults;

        #region Gurobi model
        GRBModel model;
        GRBEnv env;
        /// <summary>
        /// Power generated by each generator (in MW).
        /// </summary>
        GRBVar[] PGen;
        /// <summary>
        /// Power flow through each transmission line in the power system (in MW).
        /// </summary>
        GRBVar[] PFlow;
        /// <summary>
        /// Angle (in radians) of each bus (including reference).
        /// </summary>
        GRBVar[] BusAngle;
        /// <summary>
        /// Load shedding (in MW).
        /// </summary>
        /// <remarks>Including load shedding in the model allows it to be always feasible with null power flows in every branch.</remarks>
        GRBVar[] LoadShed;
        /// <summary>
        /// Nodal power balance (for each node).
        /// </summary>
        GRBConstr[] NodalPowerBalance;
        /// <summary>
        /// DC power flow equations (for each transmission line).
        /// </summary>
        GRBConstr[] DCPowerFlow;
        #endregion

        #region Public properties
        /// <summary>
        /// Gets the total generation cost (the model objective value) of this OPF.
        /// </summary>
        public double TotalGenerationCost
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.ObjVal);
            }
        }

        /// <summary>
        /// Gets the power generated by each generator in the current solution of the optimal power flow.
        /// </summary>
        public double[] PGen_Solution
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.X, this.PGen);
            }
        }
        /// <summary>
        /// Gets the power flow through each transmission line in the current solution of the OPF.
        /// </summary>
        public double[] PFlow_Solution
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.X, this.PFlow);
            }
        }
        /// <summary>
        /// Gets the load shedding in each node in the current solution of the OPF.
        /// </summary>
        public double[] LShed_Solution
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.X, this.LoadShed);
            }
        }

        public List<GeneratingUnitOPFResult> GeneratingUnitOPFResults
        {
            get
            {
                return _GeneratingUnitOPFResults;
            }
        }

        public List<NodeOPFResult> NodeOPFResults
        {
            get
            {
                return _NodeOPFResults;
            }
            private set
            {
                _NodeOPFResults = value;
            }
        }

        public List<TransmissionLineOPFResult> TransmissionLineOPFResults
        {
            get
            {
                return _TransmissionLineOPFResults;
            }
            private set
            {
                _TransmissionLineOPFResults = value;
            }
        }
        #endregion

        private PowerSystemSolverResults SolverResults;

        private OPFModelResult OPFResults;

        /// <summary>
        /// Creates the Gurobi OPF model for the provided power system.
        /// </summary>
        /// <param name="powerSystem">The power system for which the OPF will be solved.</param>
        public OPFModel(PowerSystemDecorator powerSystem)
        {
            this.powerSystem = powerSystem;
            this.env = new GRBEnv();
            this.model = new GRBModel(env);
            // Add variables to Gurobi model: power generated by each generator
            AddGRBVarsPGen(powerSystem);
            // Add variables to Gurobi model: bus angles
            AddGRBVarsBusAngles(powerSystem);
            // Add variables to Gurobi model: fictitious power generated in each bus (load shedding)
            AddGRBVarsLoadShed(powerSystem);
            // Add variables to Gurobi model: power flow through each transmission line
            AddGRBVarsPFlow(powerSystem);
            // Includes variables in model
            this.model.Update();
            // Sets objective: minimize total generation costs
            this.model.Set(GRB.IntAttr.ModelSense, GRB.MINIMIZE);
            // Creates power balance constraint in each node
            AddGRBConstrPowerBalance(powerSystem);
            // Creates constraint for defining power flow in each transmission line
            AddGRBConstrDCPowerFlow(powerSystem);
            //FOR DEBUGGING: Writes the resulting model to an output file
            this.model.Write("model.lp");
        }

        private void AddGRBConstrDCPowerFlow(PowerSystemDecorator powerSystem)
        {
            this.DCPowerFlow = new GRBConstr[powerSystem.NumberOfTransmissionLines];
            for (int t = 0; t < powerSystem.NumberOfTransmissionLines; t++)
            {
                TransmissionLine tl = powerSystem.TransmissionLines[t];
                GRBLinExpr powerFlowLHS = new GRBLinExpr();
                powerFlowLHS.AddTerm(1, this.PFlow[t]);
                GRBLinExpr powerFlowRHS = new GRBLinExpr();
                powerFlowRHS.AddTerm(+tl.SusceptanceMho, this.BusAngle[tl.NodeFromID]);
                powerFlowRHS.AddTerm(-tl.SusceptanceMho, this.BusAngle[tl.NodeToID]);
                this.DCPowerFlow[t] = this.model.AddConstr(powerFlowLHS, GRB.EQUAL, powerFlowRHS, "PowerFlowTL" + t);
            }
        }

        private void AddGRBConstrPowerBalance(PowerSystemDecorator powerSystem)
        {
            this.NodalPowerBalance = new GRBConstr[powerSystem.NumberOfNodes];
            int load_shed_counter = 0;
            for (int i = 0; i < powerSystem.NumberOfNodes; i++)
            {
                Node node = powerSystem.Nodes[i];
                GRBLinExpr powerBalanceLHS = new GRBLinExpr();
                foreach (GeneratingUnit gen in node.generatingUnits)
                {
                    powerBalanceLHS.AddTerm(1, this.PGen[gen.Id]);
                }
                foreach (TransmissionLine tl in node.incomingTransmissionLines)
                {
                    powerBalanceLHS.AddTerm(+1, PFlow[tl.Id]); //incoming power flow
                }
                foreach (TransmissionLine tl in node.outgoingTransmissionLines)
                {
                    powerBalanceLHS.AddTerm(-1, PFlow[tl.Id]); //outgoing power flow
                }
                GRBLinExpr powerBalanceRHS = new GRBLinExpr();
                powerBalanceRHS.AddConstant(node.TotalLoad);
                if (node.TotalLoad > 0)
                {
                    powerBalanceRHS.AddTerm(+1, LoadShed[load_shed_counter]);
                    load_shed_counter++;
                }
                this.NodalPowerBalance[i] = this.model.AddConstr(powerBalanceLHS, GRB.EQUAL, powerBalanceRHS, "PowerBalanceNode" + i);
            }
        }

        private void AddGRBVarsPFlow(PowerSystemDecorator powerSystem)
        {
            PFlow = new GRBVar[powerSystem.NumberOfTransmissionLines];
            for (int i = 0; i < powerSystem.NumberOfTransmissionLines; i++)
            {
                TransmissionLine tl = powerSystem.TransmissionLines[i];
                PFlow[i] = model.AddVar(-tl.ThermalCapacityMW, tl.ThermalCapacityMW, 0, GRB.CONTINUOUS, "PFlow" + tl.Id);
            }
        }

        private void AddGRBVarsLoadShed(PowerSystemDecorator powerSystem)
        {
            List<GRBVar> load_shed = new List<GRBVar>();
            foreach (Node node in powerSystem.Nodes)
            {
                if (node.TotalLoad > 0)
                {
                    load_shed.Add(model.AddVar(0, node.TotalLoad, OPFModel.LoadSheddingCost, GRB.CONTINUOUS, "LS" + node.Id));
                }
            }
            this.LoadShed = load_shed.ToArray<GRBVar>();
        }

        private void AddGRBVarsBusAngles(PowerSystemDecorator powerSystem)
        {
            BusAngle = new GRBVar[powerSystem.NumberOfNodes];
            for (int i = 0; i < powerSystem.NumberOfNodes; i++)
            {
                BusAngle[i] = model.AddVar(-GRB.INFINITY, GRB.INFINITY, 0, GRB.CONTINUOUS, "theta" + powerSystem.Nodes[i].Id);
            }
        }

        private void AddGRBVarsPGen(PowerSystemDecorator powerSystem)
        {
            PGen = new GRBVar[powerSystem.NumberOfGeneratingUnits];
            for (int i = 0; i < powerSystem.NumberOfGeneratingUnits; i++)
            {
                GeneratingUnit gen = powerSystem.GeneratingUnits[i];
                PGen[i] = model.AddVar(0, gen.InstalledCapacityMW, gen.MarginalCost, GRB.CONTINUOUS, "PGen" + gen.Id);
            }
        }

        /// <summary>
        /// Synchronously solves the Gurobi linear optimal (DC) power flow model.
        /// </summary>
        public void Solve()
        {
            // Initializes result reporting
            this.SolverResults = new PowerSystemSolverResults();
            this.SolverResults.SolverName = OPFModel.OPFModelName;
            this.SolverResults.StartTime = DateTime.Now;
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();
            // Solves the model
            this.model.Optimize();
            // Finalizes result reporting
            int status = this.model.Get(GRB.IntAttr.Status);
            if (status == GRB.Status.OPTIMAL)
            {
                this.OPFResults = new OPFModelResult(this.TotalGenerationCost, this.PGen_Solution, this.PFlow_Solution, status);
                this.SolverResults.Result = this.OPFResults;
                this._GeneratingUnitOPFResults = new List<GeneratingUnitOPFResult>();
                foreach (GeneratingUnit gen in powerSystem.GeneratingUnits)
                {
                    this._GeneratingUnitOPFResults.Add(new GeneratingUnitOPFResult(gen, this.OPFResults.PowerGenerated[gen.Id]));
                }
                this.NodeOPFResults = new List<NodeOPFResult>();
                foreach (Node node in powerSystem.Nodes)
                {
                    this.NodeOPFResults.Add(new NodeOPFResult(node,this.BusAngle[node.Id]));
                }
            }
            else
            {
                this.SolverResults.Result = new OPFModelResult(status);
            }
            stopwatch.Stop();
            this.SolverResults.ExecutionTime = stopwatch.Elapsed;
            this.SolverResults.StopTime = DateTime.Now;
        }

        public void SolveAsync()
        {
            throw new NotImplementedException();
        }

        public PowerSystemSolverResults getResults()
        {
            return this.SolverResults;
        }

        /// <summary>
        /// Dispose of Gurobi model and env
        /// </summary>
        public void Dispose()
        {
            model.Dispose();
            env.Dispose();
        }
    }

    /// <summary>
    /// Encapsulates results of the OPF model.
    /// </summary>
    public class OPFModelResult
    {
        double _TotalGenerationCost;
        double[] _PowerGenerated;
        double[] _PowerFlows;
        int _GRBStatus;

        /// <summary>
        /// Gets the total generation cost (the model objective value) in the current solution.
        /// </summary>
        public double TotalGenerationCost
        {
            get
            {
                return _TotalGenerationCost;
            }
        }

        /// <summary>
        /// Power generated by each generator (in MW).
        /// </summary>
        public double[] PowerGenerated
        {
            get
            {
                return _PowerGenerated;
            }
        }

        /// <summary>
        /// Power flow through each transmission line in the power system (in MW).
        /// </summary>
        public double[] PowerFlows
        {
            get
            {
                return _PowerFlows;
            }

            set
            {
                _PowerFlows = value;
            }
        }

        /// <summary>
        /// Status of the Gurobi optimization (defined in GRB.Status)
        /// </summary>
        public int GRBStatus
        {
            get
            {
                return _GRBStatus;
            }

            set
            {
                _GRBStatus = value;
            }
        }

        /// <summary>
        /// True if the model was solved to optimality, false otherwise.
        /// </summary>
        public bool IsModelSolved { get { return _GRBStatus == GRB.Status.OPTIMAL; } }

        /// <summary>
        /// True if the model was proved to be infeasible, false otherwise.
        /// </summary>
        public bool IsModelInfeasible { get { return _GRBStatus == GRB.Status.INFEASIBLE; } }

        /// <summary>
        /// True if the model was proved to be unbounded, false otherwise.
        /// </summary>
        public bool IsModelUnbounded { get { return _GRBStatus == GRB.Status.UNBOUNDED; } }

        /// <summary>
        /// Initializes the result container with the given Gurobi status.
        /// </summary>
        /// <param name="status">The Gurobi status of the optimization</param>
        /// <remarks>This constructor can be used to find out if the model was correctly solved by means of the <see cref="IsModelSolved"/> property.</remarks>
        public OPFModelResult(int status)
        {
            this._GRBStatus = status;
        }

        public OPFModelResult(double obj, double[] pgen, double[] pflows, int status)
            : this(status)
        {
            this._TotalGenerationCost = obj;
            this._PowerGenerated = pgen;
            this._PowerFlows = pflows;
        }
    }

    /// <summary>
    /// Encapsulator of the OPF result of a generating unit (output, in MW).
    /// </summary>
    public class GeneratingUnitOPFResult
    {
        GeneratingUnit _GeneratingUnit;

        double _Output;

        public GeneratingUnit GeneratingUnit
        {
            get
            {
                return _GeneratingUnit;
            }
        }

        public double Output
        {
            get
            {
                return _Output;
            }
        }

        public GeneratingUnitOPFResult(GeneratingUnit generatingUnit, double output)
        {
            this._GeneratingUnit = generatingUnit;
            this._Output = output;
        }
    }

    /// <summary>
    /// Encapsulator of the OPF result of a node (bus angle and load shedding).
    /// </summary>
    public class NodeOPFResult
    {
        Node _Node;
        double _Angle;
        double _LoadShedding;

        public double LoadShedding
        {
            get
            {
                return _LoadShedding;
            }
            private set
            {
                _LoadShedding = value;
            }
        }

        public Node Node
        {
            get
            {
                return _Node;
            }
            private set
            {
                _Node = value;
            }
        }

        public double Angle
        {
            get
            {
                return _Angle;
            }
            private set
            {
                _Angle = value;
            }
        }

        public NodeOPFResult(Node node, double angle, double load_shed)
        {
            this.Node = node;
            this.Angle = angle;
            this.LoadShedding = load_shed;
        }
    }

    /// <summary>
    /// Encapsulator of the OPF result of a transmission line (power flow in MW).
    /// </summary>
    public class TransmissionLineOPFResult
    {
        TransmissionLine _TransmissionLine;
        double _PowerFlow;

        public TransmissionLine TransmissionLine
        {
            get
            {
                return _TransmissionLine;
            }
            private set
            {
                _TransmissionLine = value;
            }
        }

        public double PowerFlow
        {
            get
            {
                return _PowerFlow;
            }
            private set
            {
                _PowerFlow = value;
            }
        }

        public TransmissionLineOPFResult(TransmissionLine transmissionLine, double power_flow)
        {
            this.TransmissionLine = transmissionLine;
            this.PowerFlow = power_flow;
        }
    }
}
