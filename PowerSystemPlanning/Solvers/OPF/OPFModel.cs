using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Gurobi;
using System.Diagnostics;

namespace PowerSystemPlanning.Solvers.OPF
{
    /// <summary>
    /// Linear programming optimal power flow model (DC power flow, linear generation cost functions).
    /// </summary>
    /// <remarks>
    /// The most simple OPF model based on DC power flow. Load shedding is allowed (modeled as fictitious generation) so the problem is always feasible (by shedding all load in every bus of the power system).
    /// </remarks>
    public class OPFModel : IPowerSystemSolver
    {
        public const string OPFModelName = "Linear Optimal (DC) Power Flow";

        PowerSystem powerSystem;

        #region Gurobi model
        GRBModel model;
        GRBEnv env;
        /// <summary>
        /// Power generated by each generator (in MW).
        /// </summary>
        GRBVar[] PGen;
        /// <summary>
        /// Power flow through each transmission line in the power system (in MW).
        /// </summary>
        GRBVar[] PFlow;
        /// <summary>
        /// Load shedding (in MW).
        /// </summary>
        /// <remarks>Including load shedding in the model allows it to be always feasible with null power flows in every branch.</remarks>
        GRBVar[] LoadShed;
        /// <summary>
        /// Angle (in radians) of each bus (including reference).
        /// </summary>
        GRBVar[] BusAngle;
        /// <summary>
        /// Nodal power balance (for each node).
        /// </summary>
        GRBConstr[] NodalPowerBalance;
        /// <summary>
        /// DC power flow equations (for each transmission line).
        /// </summary>
        GRBConstr[] DCPowerFlow;
        #endregion

        #region Results of the model
        /// <summary>
        /// Gets the total generation cost (the model objective value) of this OPF.
        /// </summary>
        double TotalGenerationCost
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.ObjVal);
            }
        }
        /// <summary>
        /// Gets the power generated by each generator in the current solution of the optimal power flow.
        /// </summary>
        double[] PGen_Solution
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.X, this.PGen);
            }
        }
        /// <summary>
        /// Gets the power flow through each transmission line in the current solution of the OPF.
        /// </summary>
        double[] PFlow_Solution
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.X, this.PFlow);
            }
        }
        /// <summary>
        /// Gets the load shedding in each node in the current solution of the OPF.
        /// </summary>
        double[] LShed_Solution
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.X, this.LoadShed);
            }
        }
        double[] BusAng_Solution
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.X, this.BusAngle);
            }
        }
        /// <summary>
        /// The spot price (US$/MW) in each node of the power system.
        /// </summary>
        /// <remarks>
        /// The nodal spot price (also known as locational marginal price) is equal to the shadow price of the power balance constraint. Since all loads are assumed to be inelastic, the market-clearing price is simply the cost of satisfying one additional MW of load in the given node. Absent transmission congestion and load shedding, there will be one unique price in all nodes, and it will be equal to the marginal cost of the most expensive generator running.
        /// </remarks>
        double[] NodalSpotPrice
        {
            get
            {
                return this.model.Get(GRB.DoubleAttr.Pi, this.NodalPowerBalance);
            }
        }
        #endregion

        private PowerSystemSolverResults SolverResults;

        /// <summary>
        /// The detailed results of this OPF model (per node, generator, and transmission line).
        /// </summary>
        private OPFModelResult OPFResults;

        /// <summary>
        /// Creates the Gurobi OPF model for the provided power system.
        /// </summary>
        /// <param name="powerSystem">The power system for which the OPF will be solved.</param>
        public OPFModel(PowerSystem powerSystem)
        {
            this.powerSystem = powerSystem;
            this.env = new GRBEnv();
            this.model = new GRBModel(env);
            // Add variables to Gurobi model: power generated by each generator
            AddGRBVarsPGen();
            // Add variables to Gurobi model: bus angles
            AddGRBVarsBusAngles();
            // Add variables to Gurobi model: fictitious power generated in each bus (load shedding)
            AddGRBVarsLoadShed();
            // Add variables to Gurobi model: power flow through each transmission line
            AddGRBVarsPFlow();
            // Includes variables in model
            this.model.Update();
            // Sets objective: minimize total generation costs
            this.model.Set(GRB.IntAttr.ModelSense, GRB.MINIMIZE);
            // Creates power balance constraint in each node
            AddGRBConstrPowerBalance();
            // Creates constraint for defining power flow in each transmission line
            AddGRBConstrDCPowerFlow();
            //FOR DEBUGGING: Writes the resulting model to an output file
            string modelFilename = "OPFModel_" + powerSystem.Name + ".lp";
            this.model.Write(modelFilename);
        }

        /// <summary>
        /// Creates Gurobi constraints of DC Power flow.
        /// </summary>
        /// <param name="powerSystem"></param>
        /// <remarks>The DC power flow constraints relate active power flow through branches to node angles:
        /// \f[
        ///     P_{flow,i \to j} = B_{ij} \left( \theta_i - \theta_j \right)
        /// \f]</remarks>
        protected void AddGRBConstrDCPowerFlow()
        {
            this.DCPowerFlow = new GRBConstr[powerSystem.NumberOfTransmissionLines];
            for (int t = 0; t < powerSystem.NumberOfTransmissionLines; t++)
            {
                TransmissionLine tl = powerSystem.TransmissionLines[t];
                GRBLinExpr powerFlowLHS = new GRBLinExpr();
                powerFlowLHS.AddTerm(1, this.PFlow[t]);
                GRBLinExpr powerFlowRHS = new GRBLinExpr();
                powerFlowRHS.AddTerm(+tl.SusceptanceMho, this.BusAngle[tl.NodeFromID]);
                powerFlowRHS.AddTerm(-tl.SusceptanceMho, this.BusAngle[tl.NodeToID]);
                this.DCPowerFlow[t] = this.model.AddConstr(powerFlowLHS, GRB.EQUAL, powerFlowRHS, "PowerFlowTL" + t);
            }
        }

        protected void AddGRBConstrPowerBalance()
        {
            this.NodalPowerBalance = new GRBConstr[powerSystem.NumberOfNodes];
            int load_shed_counter = 0;
            for (int i = 0; i < powerSystem.NumberOfNodes; i++)
            {
                Node node = powerSystem.Nodes[i];
                GRBLinExpr powerBalanceLHS = new GRBLinExpr();
                foreach (GeneratingUnit gen in node.GeneratingUnits)
                {
                    powerBalanceLHS.AddTerm(1, this.PGen[gen.Id]);
                }
                foreach (TransmissionLine tl in node.IncomingTransmissionLines)
                {
                    powerBalanceLHS.AddTerm(+1, PFlow[tl.Id]); //incoming power flow
                }
                foreach (TransmissionLine tl in node.OutgoingTransmissionLines)
                {
                    powerBalanceLHS.AddTerm(-1, PFlow[tl.Id]); //outgoing power flow
                }
                GRBLinExpr powerBalanceRHS = new GRBLinExpr();
                powerBalanceRHS.AddConstant(node.TotalLoad);
                if (node.TotalLoad > 0)
                {
                    powerBalanceRHS.AddTerm(-1, LoadShed[load_shed_counter]);
                    load_shed_counter++;
                }
                this.NodalPowerBalance[i] = this.model.AddConstr(powerBalanceLHS, GRB.EQUAL, powerBalanceRHS, "PowerBalanceNode" + i);
            }
        }

        protected void AddGRBVarsPFlow()
        {
            PFlow = new GRBVar[powerSystem.NumberOfTransmissionLines];
            for (int i = 0; i < powerSystem.NumberOfTransmissionLines; i++)
            {
                TransmissionLine tl = powerSystem.TransmissionLines[i];
                PFlow[i] = model.AddVar(-tl.ThermalCapacityMW, tl.ThermalCapacityMW, 0, GRB.CONTINUOUS, "PFlow" + tl.Id);
            }
        }

        protected void AddGRBVarsLoadShed()
        {
            List<GRBVar> load_shed = new List<GRBVar>();
            foreach (Node node in powerSystem.Nodes)
            {
                if (node.TotalLoad > 0)
                {
                    load_shed.Add(model.AddVar(0, node.TotalLoad, powerSystem.LoadSheddingCost, GRB.CONTINUOUS, "LS" + node.Id));
                }
            }
            this.LoadShed = load_shed.ToArray<GRBVar>();
        }

        protected void AddGRBVarsBusAngles()
        {
            BusAngle = new GRBVar[powerSystem.NumberOfNodes];
            for (int i = 0; i < powerSystem.NumberOfNodes; i++)
            {
                BusAngle[i] = model.AddVar(-GRB.INFINITY, GRB.INFINITY, 0, GRB.CONTINUOUS, "theta" + powerSystem.Nodes[i].Id);
            }
        }

        protected void AddGRBVarsPGen()
        {
            PGen = new GRBVar[powerSystem.NumberOfGeneratingUnits];
            for (int i = 0; i < powerSystem.NumberOfGeneratingUnits; i++)
            {
                GeneratingUnit gen = powerSystem.GeneratingUnits[i];
                PGen[i] = model.AddVar(0, gen.InstalledCapacityMW, gen.MarginalCost, GRB.CONTINUOUS, "PGen" + gen.Id);
            }
        }

        /// <summary>
        /// Synchronously solves the Gurobi linear optimal (DC) power flow model.
        /// </summary>
        public void Solve()
        {
            // Initializes result reporting
            this.SolverResults = new PowerSystemSolverResults();
            this.SolverResults.SolverName = OPFModel.OPFModelName;
            this.SolverResults.StartTime = DateTime.Now;
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();
            // Solves the model
            this.model.Optimize();
            // Finalizes result reporting
            int status = this.model.Get(GRB.IntAttr.Status);
            if (status == GRB.Status.OPTIMAL)
            {
                this.OPFResults = new OPFModelResult(powerSystem, status, TotalGenerationCost, PGen_Solution, PFlow_Solution, LShed_Solution, BusAng_Solution, NodalSpotPrice);
            }
            else
            {
                this.OPFResults = new OPFModelResult(status);
            }
            this.SolverResults.Result = this.OPFResults;
            stopwatch.Stop();
            this.SolverResults.ExecutionTime = stopwatch.Elapsed;
            this.SolverResults.StopTime = DateTime.Now;
        }

        public void SolveAsync()
        {
            throw new NotImplementedException();
        }

        public PowerSystemSolverResults getResults()
        {
            return this.SolverResults;
        }

        /// <summary>
        /// Dispose of Gurobi model and env
        /// </summary>
        public void Dispose()
        {
            model.Dispose();
            env.Dispose();
        }
    }
}
